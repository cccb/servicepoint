# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .rb file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Ruby
# helpers directly inline like we're doing here.

require 'ffi'


module ServicepointBindingUniffi
  def self.uniffi_in_range(i, type_name, min, max)
  raise TypeError, "no implicit conversion of #{i} into Integer" unless i.respond_to?(:to_int)
  i = i.to_int
  raise RangeError, "#{type_name} requires #{min} <= value < #{max}" unless (min <= i && i < max)
  i
end

def self.uniffi_utf8(v)
  raise TypeError, "no implicit conversion of #{v} into String" unless v.respond_to?(:to_str)
  v = v.to_str.encode(Encoding::UTF_8)
  raise Encoding::InvalidByteSequenceError, "not a valid UTF-8 encoded string" unless v.valid_encoding?
  v
end

def self.uniffi_bytes(v)
  raise TypeError, "no implicit conversion of #{v} into String" unless v.respond_to?(:to_str)
  v.to_str
end

  class RustBuffer < FFI::Struct
  layout :capacity, :int32,
         :len,      :int32,
         :data,     :pointer

  def self.alloc(size)
    return ServicepointBindingUniffi.rust_call(:ffi_servicepoint_binding_uniffi_rustbuffer_alloc, size)
  end

  def self.reserve(rbuf, additional)
    return ServicepointBindingUniffi.rust_call(:ffi_servicepoint_binding_uniffi_rustbuffer_reserve, rbuf, additional)
  end

  def free
    ServicepointBindingUniffi.rust_call(:ffi_servicepoint_binding_uniffi_rustbuffer_free, self)
  end

  def capacity
    self[:capacity]
  end

  def len
    self[:len]
  end

  def len=(value)
    self[:len] = value
  end

  def data
    self[:data]
  end

  def to_s
    "RustBuffer(capacity=#{capacity}, len=#{len}, data=#{data.read_bytes len})"
  end

  # The allocated buffer will be automatically freed if an error occurs, ensuring that
  # we don't accidentally leak it.
  def self.allocWithBuilder
    builder = RustBufferBuilder.new

    begin
      yield builder
    rescue => e
      builder.discard
      raise e
    end
  end

  # The RustBuffer will be freed once the context-manager exits, ensuring that we don't
  # leak it even if an error occurs.
  def consumeWithStream
    stream = RustBufferStream.new self

    yield stream

    raise RuntimeError, 'junk data left in buffer after consuming' if stream.remaining != 0
  ensure
    free
  end# The primitive String type.

  def self.allocFromString(value)
    RustBuffer.allocWithBuilder do |builder|
      builder.write value.encode('utf-8')
      return builder.finalize
    end
  end

  def consumeIntoString
    consumeWithStream do |stream|
      return stream.read(stream.remaining).force_encoding(Encoding::UTF_8)
    end
  end

  # The primitive Bytes type.

  def self.allocFromBytes(value)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Bytes(value)
      return builder.finalize
    end
  end

  def consumeIntoBytes
    consumeWithStream do |stream|
      return stream.readBytes
    end
  end

  # The Record type Constants.

  def self.alloc_from_TypeConstants(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeConstants(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeConstants
    consumeWithStream do |stream|
      return stream.readTypeConstants
    end
  end

  

  # The Enum type CompressionCode.

  def self.alloc_from_TypeCompressionCode(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeCompressionCode(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeCompressionCode
    consumeWithStream do |stream|
      return stream.readTypeCompressionCode
    end
  end
  

  

  
end

module UniFFILib
  class ForeignBytes < FFI::Struct
    layout :len,      :int32,
           :data,     :pointer

    def len
      self[:len]
    end

    def data
      self[:data]
    end

    def to_s
      "ForeignBytes(len=#{len}, data=#{data.read_bytes(len)})"
    end
  end
end

private_constant :UniFFILib
  
# Helper for structured reading of values from a RustBuffer.
class RustBufferStream

  def initialize(rbuf)
    @rbuf = rbuf
    @offset = 0
  end

  def remaining
    @rbuf.len - @offset
  end

  def read(size)
    raise InternalError, 'read past end of rust buffer' if @offset + size > @rbuf.len

    data = @rbuf.data.get_bytes @offset, size

    @offset += size

    data
  end

  def readU8
    unpack_from 1, 'c'
  end

  def readU64
    unpack_from 8, 'Q>'
  end

  def readBool
    v = unpack_from 1, 'c'

    return false if v == 0
    return true if v == 1

    raise InternalError, 'Unexpected byte for Boolean type'
  end

  def readString
    size = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative string length' if size.negative?

    read(size).force_encoding(Encoding::UTF_8)
  end

  def readBytes
    size = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative byte string length' if size.negative?

    read(size).force_encoding(Encoding::BINARY)
  end

  # The Object type BitVec.

  def readTypeBitVec
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return BitVec._uniffi_allocate(pointer)
  end

  # The Object type Bitmap.

  def readTypeBitmap
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return Bitmap._uniffi_allocate(pointer)
  end

  # The Object type BrightnessGrid.

  def readTypeBrightnessGrid
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return BrightnessGrid._uniffi_allocate(pointer)
  end

  # The Object type CharGrid.

  def readTypeCharGrid
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return CharGrid._uniffi_allocate(pointer)
  end

  # The Object type Command.

  def readTypeCommand
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return Command._uniffi_allocate(pointer)
  end

  # The Object type Connection.

  def readTypeConnection
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return Connection._uniffi_allocate(pointer)
  end

  # The Object type Cp437Grid.

  def readTypeCp437Grid
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return Cp437Grid._uniffi_allocate(pointer)
  end

  # The Record type Constants.

  def readTypeConstants
    Constants.new(
      readU64,
      readU64,
      readU64,
      readU64,
      readU64,
      readU64
    )
  end

  

  

  # The Error type CharGridError

  def readTypeCharGridError
    variant = unpack_from 4, 'l>'
    
    if variant == 1
        return CharGridError::StringNotOneChar.new(
            readString()
        )
    end
    if variant == 2
        return CharGridError::InvalidSeriesLength.new(
            readU64(),
            readU64()
        )
    end
    if variant == 3
        return CharGridError::OutOfBounds.new(
            readU64(),
            readU64()
        )
    end

    raise InternalError, 'Unexpected variant tag for TypeCharGridError'
  end
  

  
  
  # The Enum type CompressionCode.

  def readTypeCompressionCode
    variant = unpack_from 4, 'l>'
    
    if variant == 1
      return CompressionCode::UNCOMPRESSED
    end
    if variant == 2
      return CompressionCode::ZLIB
    end
    if variant == 3
      return CompressionCode::BZIP2
    end
    if variant == 4
      return CompressionCode::LZMA
    end
    if variant == 5
      return CompressionCode::ZSTD
    end

    raise InternalError, 'Unexpected variant tag for TypeCompressionCode'
  end

  

  

  

  # The Error type ServicePointError

  def readTypeServicePointError
    variant = unpack_from 4, 'l>'
    
    if variant == 1
        return ServicePointError::IoError.new(
            readString()
        )
    end
    if variant == 2
        return ServicePointError::InvalidBrightness.new(
            readU8()
        )
    end

    raise InternalError, 'Unexpected variant tag for TypeServicePointError'
  end
  

  

  def unpack_from(size, format)
    raise InternalError, 'read past end of rust buffer' if @offset + size > @rbuf.len

    value = @rbuf.data.get_bytes(@offset, size).unpack format

    @offset += size

    # TODO: verify this
    raise 'more than one element!!!' if value.size > 1

    value[0]
  end
end

private_constant :RustBufferStream
  
# Helper for structured writing of values into a RustBuffer.
class RustBufferBuilder
  def initialize
    @rust_buf = RustBuffer.alloc 16
    @rust_buf.len = 0
  end

  def finalize
    rbuf = @rust_buf

    @rust_buf = nil

    rbuf
  end

  def discard
    return if @rust_buf.nil?

    rbuf = finalize
    rbuf.free
  end

  def write(value)
    reserve(value.bytes.size) do
      @rust_buf.data.put_array_of_char @rust_buf.len, value.bytes
    end
  end

  def write_U8(v)
    v = ServicepointBindingUniffi::uniffi_in_range(v, "u8", 0, 2**8)
    pack_into(1, 'c', v)
  end

  def write_U64(v)
    v = ServicepointBindingUniffi::uniffi_in_range(v, "u64", 0, 2**64)
    pack_into(8, 'Q>', v)
  end

  def write_Bool(v)
    pack_into(1, 'c', v ? 1 : 0)
  end

  def write_String(v)
    v = ServicepointBindingUniffi::uniffi_utf8(v)
    pack_into 4, 'l>', v.bytes.size
    write v
  end

  def write_Bytes(v)
    v = ServicepointBindingUniffi::uniffi_bytes(v)
    pack_into 4, 'l>', v.bytes.size
    write v
  end

  # The Object type BitVec.

  def write_TypeBitVec(obj)
    pointer = BitVec._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type Bitmap.

  def write_TypeBitmap(obj)
    pointer = Bitmap._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type BrightnessGrid.

  def write_TypeBrightnessGrid(obj)
    pointer = BrightnessGrid._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type CharGrid.

  def write_TypeCharGrid(obj)
    pointer = CharGrid._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type Command.

  def write_TypeCommand(obj)
    pointer = Command._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type Connection.

  def write_TypeConnection(obj)
    pointer = Connection._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type Cp437Grid.

  def write_TypeCp437Grid(obj)
    pointer = Cp437Grid._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Record type Constants.

  def write_TypeConstants(v)
    self.write_U64(v.tile_size)
    self.write_U64(v.tile_width)
    self.write_U64(v.tile_height)
    self.write_U64(v.pixel_width)
    self.write_U64(v.pixel_height)
    self.write_U64(v.pixel_count)
  end

  

  # The Enum type CompressionCode.

  def write_TypeCompressionCode(v)
    pack_into(4, 'l>', v)
 end
   

  

  

  private

  def reserve(num_bytes)
    if @rust_buf.len + num_bytes > @rust_buf.capacity
      @rust_buf = RustBuffer.reserve(@rust_buf, num_bytes)
    end

    yield

    @rust_buf.len += num_bytes
  end

  def pack_into(size, format, value)
    reserve(size) do
      @rust_buf.data.put_array_of_char @rust_buf.len, [value].pack(format).bytes
    end
  end
end

private_constant :RustBufferBuilder

  # Error definitions
  class RustCallStatus < FFI::Struct
  layout :code,    :int8,
         :error_buf, RustBuffer

  def code
    self[:code]
  end

  def error_buf
    self[:error_buf]
  end

  def to_s
    "RustCallStatus(code=#{self[:code]})"
  end
end

# These match the values from the uniffi::rustcalls module
CALL_SUCCESS = 0
CALL_ERROR = 1
CALL_PANIC = 2


module CharGridError
  class StringNotOneChar < StandardError
    def initialize(value)
        @value = value
        super()
      end

    attr_reader :value
    

    def to_s
     "#{self.class.name}(value=#{@value.inspect})"
    end
  end
  class InvalidSeriesLength < StandardError
    def initialize(actual, expected)
        @actual = actual
        @expected = expected
        super()
      end

    attr_reader :actual, :expected
    

    def to_s
     "#{self.class.name}(actual=#{@actual.inspect}, expected=#{@expected.inspect})"
    end
  end
  class OutOfBounds < StandardError
    def initialize(index, size)
        @index = index
        @size = size
        super()
      end

    attr_reader :index, :size
    

    def to_s
     "#{self.class.name}(index=#{@index.inspect}, size=#{@size.inspect})"
    end
  end

end




module ServicePointError
  class IoError < StandardError
    def initialize(error)
        @error = error
        super()
      end

    attr_reader :error
    

    def to_s
     "#{self.class.name}(error=#{@error.inspect})"
    end
  end
  class InvalidBrightness < StandardError
    def initialize(value)
        @value = value
        super()
      end

    attr_reader :value
    

    def to_s
     "#{self.class.name}(value=#{@value.inspect})"
    end
  end

end


# Map error modules to the RustBuffer method name that reads them
ERROR_MODULE_TO_READER_METHOD = {

  CharGridError => :readTypeCharGridError,



  ServicePointError => :readTypeServicePointError,

}

private_constant :ERROR_MODULE_TO_READER_METHOD, :CALL_SUCCESS, :CALL_ERROR, :CALL_PANIC,
                 :RustCallStatus

def self.consume_buffer_into_error(error_module, rust_buffer)
  rust_buffer.consumeWithStream do |stream|
    reader_method = ERROR_MODULE_TO_READER_METHOD[error_module]
    return stream.send(reader_method)
  end
end

class InternalError < StandardError
end

def self.rust_call(fn_name, *args)
  # Call a rust function
  rust_call_with_error(nil, fn_name, *args)
end

def self.rust_call_with_error(error_module, fn_name, *args)
  # Call a rust function and handle errors
  #
  # Use this when the rust function returns a Result<>.  error_module must be the error_module that corresponds to that Result.


  # Note: RustCallStatus.new zeroes out the struct, which is exactly what we
  # want to pass to Rust (code=0, error_buf=RustBuffer(len=0, capacity=0,
  # data=NULL))
  status = RustCallStatus.new
  args << status

  result = UniFFILib.public_send(fn_name, *args)

  case status.code
  when CALL_SUCCESS
    result
  when CALL_ERROR
    if error_module.nil?
      status.error_buf.free
      raise InternalError, "CALL_ERROR with no error_module set"
    else
      raise consume_buffer_into_error(error_module, status.error_buf)
    end
  when CALL_PANIC
    # When the rust code sees a panic, it tries to construct a RustBuffer
    # with the message.  But if that code panics, then it just sends back
    # an empty buffer.
    if status.error_buf.len > 0
      raise InternalError, status.error_buf.consumeIntoString()
    else
      raise InternalError, "Rust panic"
    end
  else
    raise InternalError, "Unknown call status: #{status.code}"
  end
end

private_class_method :consume_buffer_into_error

  # This is how we find and load the dynamic library provided by the component.
# For now we just look it up by name.
module UniFFILib
  extend FFI::Library

  
  ffi_lib 'servicepoint_binding_uniffi'
  

  attach_function :uniffi_servicepoint_binding_uniffi_fn_free_bitvec,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_bitvec_clone,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_bitvec_load,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_bitvec_new,
    [:uint64, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_bitvec_copy_raw,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_bitvec_equals,
    [:pointer, :pointer, RustCallStatus.by_ref],
    :int8
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_bitvec_fill,
    [:pointer, :int8, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_bitvec_get,
    [:pointer, :uint64, RustCallStatus.by_ref],
    :int8
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_bitvec_len,
    [:pointer, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_bitvec_set,
    [:pointer, :uint64, :int8, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_servicepoint_binding_uniffi_fn_free_bitmap,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_bitmap_clone,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_bitmap_load,
    [:uint64, :uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_bitmap_new,
    [:uint64, :uint64, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_bitmap_new_max_sized,
    [RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_bitmap_copy_raw,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_bitmap_equals,
    [:pointer, :pointer, RustCallStatus.by_ref],
    :int8
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_bitmap_fill,
    [:pointer, :int8, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_bitmap_get,
    [:pointer, :uint64, :uint64, RustCallStatus.by_ref],
    :int8
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_bitmap_height,
    [:pointer, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_bitmap_set,
    [:pointer, :uint64, :uint64, :int8, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_bitmap_width,
    [:pointer, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_servicepoint_binding_uniffi_fn_free_brightnessgrid,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_brightnessgrid_clone,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_brightnessgrid_load,
    [:uint64, :uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_brightnessgrid_new,
    [:uint64, :uint64, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_brightnessgrid_copy_raw,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_brightnessgrid_equals,
    [:pointer, :pointer, RustCallStatus.by_ref],
    :int8
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_brightnessgrid_fill,
    [:pointer, :uint8, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_brightnessgrid_get,
    [:pointer, :uint64, :uint64, RustCallStatus.by_ref],
    :uint8
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_brightnessgrid_height,
    [:pointer, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_brightnessgrid_set,
    [:pointer, :uint64, :uint64, :uint8, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_brightnessgrid_width,
    [:pointer, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_servicepoint_binding_uniffi_fn_free_chargrid,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_chargrid_clone,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_chargrid_load,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_chargrid_new,
    [:uint64, :uint64, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_chargrid_as_string,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_chargrid_equals,
    [:pointer, :pointer, RustCallStatus.by_ref],
    :int8
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_chargrid_fill,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_chargrid_get,
    [:pointer, :uint64, :uint64, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_chargrid_get_col,
    [:pointer, :uint64, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_chargrid_get_row,
    [:pointer, :uint64, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_chargrid_height,
    [:pointer, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_chargrid_set,
    [:pointer, :uint64, :uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_chargrid_set_col,
    [:pointer, :uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_chargrid_set_row,
    [:pointer, :uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_chargrid_to_cp437,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_chargrid_width,
    [:pointer, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_servicepoint_binding_uniffi_fn_free_command,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_command_bitmap_linear,
    [:uint64, :pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_command_bitmap_linear_and,
    [:uint64, :pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_command_bitmap_linear_or,
    [:uint64, :pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_command_bitmap_linear_win,
    [:uint64, :uint64, :pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_command_bitmap_linear_xor,
    [:uint64, :pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_command_brightness,
    [:uint8, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_command_char_brightness,
    [:uint64, :uint64, :pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_command_clear,
    [RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_command_clone,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_command_cp437_data,
    [:uint64, :uint64, :pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_command_fade_out,
    [RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_command_hard_reset,
    [RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_command_utf8_data,
    [:uint64, :uint64, :pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_command_equals,
    [:pointer, :pointer, RustCallStatus.by_ref],
    :int8
  attach_function :uniffi_servicepoint_binding_uniffi_fn_free_connection,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_connection_new,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_connection_new_fake,
    [RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_connection_send,
    [:pointer, :pointer, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_servicepoint_binding_uniffi_fn_free_cp437grid,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_cp437grid_clone,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_cp437grid_load,
    [:uint64, :uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_constructor_cp437grid_new,
    [:uint64, :uint64, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_cp437grid_copy_raw,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_cp437grid_equals,
    [:pointer, :pointer, RustCallStatus.by_ref],
    :int8
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_cp437grid_fill,
    [:pointer, :uint8, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_cp437grid_get,
    [:pointer, :uint64, :uint64, RustCallStatus.by_ref],
    :uint8
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_cp437grid_height,
    [:pointer, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_cp437grid_set,
    [:pointer, :uint64, :uint64, :uint8, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_cp437grid_to_utf8,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_servicepoint_binding_uniffi_fn_method_cp437grid_width,
    [:pointer, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_servicepoint_binding_uniffi_fn_func_get_constants,
    [RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_servicepoint_binding_uniffi_rustbuffer_alloc,
    [:int32, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_servicepoint_binding_uniffi_rustbuffer_from_bytes,
    [ForeignBytes, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_servicepoint_binding_uniffi_rustbuffer_free,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :ffi_servicepoint_binding_uniffi_rustbuffer_reserve,
    [RustBuffer.by_value, :int32, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_func_get_constants,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_bitvec_copy_raw,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_bitvec_equals,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_bitvec_fill,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_bitvec_get,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_bitvec_len,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_bitvec_set,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_bitmap_copy_raw,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_bitmap_equals,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_bitmap_fill,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_bitmap_get,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_bitmap_height,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_bitmap_set,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_bitmap_width,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_brightnessgrid_copy_raw,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_brightnessgrid_equals,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_brightnessgrid_fill,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_brightnessgrid_get,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_brightnessgrid_height,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_brightnessgrid_set,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_brightnessgrid_width,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_chargrid_as_string,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_chargrid_equals,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_chargrid_fill,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_chargrid_get,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_chargrid_get_col,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_chargrid_get_row,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_chargrid_height,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_chargrid_set,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_chargrid_set_col,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_chargrid_set_row,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_chargrid_to_cp437,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_chargrid_width,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_command_equals,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_connection_send,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_cp437grid_copy_raw,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_cp437grid_equals,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_cp437grid_fill,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_cp437grid_get,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_cp437grid_height,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_cp437grid_set,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_cp437grid_to_utf8,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_method_cp437grid_width,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_bitvec_clone,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_bitvec_load,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_bitvec_new,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_bitmap_clone,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_bitmap_load,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_bitmap_new,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_bitmap_new_max_sized,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_brightnessgrid_clone,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_brightnessgrid_load,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_brightnessgrid_new,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_chargrid_clone,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_chargrid_load,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_chargrid_new,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_command_bitmap_linear,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_command_bitmap_linear_and,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_command_bitmap_linear_or,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_command_bitmap_linear_win,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_command_bitmap_linear_xor,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_command_brightness,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_command_char_brightness,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_command_clear,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_command_clone,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_command_cp437_data,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_command_fade_out,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_command_hard_reset,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_command_utf8_data,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_connection_new,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_connection_new_fake,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_cp437grid_clone,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_cp437grid_load,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_servicepoint_binding_uniffi_checksum_constructor_cp437grid_new,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :ffi_servicepoint_binding_uniffi_uniffi_contract_version,
    [RustCallStatus.by_ref],
    :uint32
  
end

  # Public interface members begin here.

  
  
  
  

class CompressionCode
  UNCOMPRESSED = 1
  ZLIB = 2
  BZIP2 = 3
  LZMA = 4
  ZSTD = 5
  
end


  
  
  # Record type Constants
class Constants
  attr_reader :tile_size, :tile_width, :tile_height, :pixel_width, :pixel_height, :pixel_count

  def initialize(tile_size, tile_width, tile_height, pixel_width, pixel_height, pixel_count)
    @tile_size = tile_size
    @tile_width = tile_width
    @tile_height = tile_height
    @pixel_width = pixel_width
    @pixel_height = pixel_height
    @pixel_count = pixel_count
  end

  def ==(other)
    if @tile_size != other.tile_size
      return false
    end
    if @tile_width != other.tile_width
      return false
    end
    if @tile_height != other.tile_height
      return false
    end
    if @pixel_width != other.pixel_width
      return false
    end
    if @pixel_height != other.pixel_height
      return false
    end
    if @pixel_count != other.pixel_count
      return false
    end

    true
  end
end
  

  
  

def self.get_constants()
  result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_func_get_constants,)
  return result.consumeIntoTypeConstants
end


  

  
  class BitVec

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      ServicepointBindingUniffi.rust_call(
        :uniffi_servicepoint_binding_uniffi_fn_free_bitvec,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a BitVec instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
  def initialize(size)
        size = ServicepointBindingUniffi::uniffi_in_range(size, "u64", 0, 2**64)
    pointer = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_bitvec_new,size)
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  def self.clone(other)
        other = other
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_bitvec_clone,(BitVec._uniffi_lower other)))
  end
  def self.load(data)
        data = ServicepointBindingUniffi::uniffi_bytes(data)
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_bitvec_load,RustBuffer.allocFromBytes(data)))
  end
  

  def copy_raw()
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_bitvec_copy_raw,@pointer,)
    return result.consumeIntoBytes
  end
  def equals(other)
        other = other
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_bitvec_equals,@pointer,(BitVec._uniffi_lower other))
    return 1 == result
  end
  def fill(value)
        value = value ? true : false
      ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_bitvec_fill,@pointer,(value ? 1 : 0))
  end
  
  def get(index)
        index = ServicepointBindingUniffi::uniffi_in_range(index, "u64", 0, 2**64)
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_bitvec_get,@pointer,index)
    return 1 == result
  end
  def len()
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_bitvec_len,@pointer,)
    return result.to_i
  end
  def set(index, value)
        index = ServicepointBindingUniffi::uniffi_in_range(index, "u64", 0, 2**64)
        value = value ? true : false
      ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_bitvec_set,@pointer,index,(value ? 1 : 0))
  end
  
  
end
  
  class Bitmap

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      ServicepointBindingUniffi.rust_call(
        :uniffi_servicepoint_binding_uniffi_fn_free_bitmap,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a Bitmap instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
  def initialize(width, height)
        width = ServicepointBindingUniffi::uniffi_in_range(width, "u64", 0, 2**64)
        height = ServicepointBindingUniffi::uniffi_in_range(height, "u64", 0, 2**64)
    pointer = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_bitmap_new,width,height)
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  def self.clone(other)
        other = other
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_bitmap_clone,(Bitmap._uniffi_lower other)))
  end
  def self.load(width, height, data)
        width = ServicepointBindingUniffi::uniffi_in_range(width, "u64", 0, 2**64)
        height = ServicepointBindingUniffi::uniffi_in_range(height, "u64", 0, 2**64)
        data = ServicepointBindingUniffi::uniffi_bytes(data)
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_bitmap_load,width,height,RustBuffer.allocFromBytes(data)))
  end
  def self.new_max_sized()
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_bitmap_new_max_sized,))
  end
  

  def copy_raw()
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_bitmap_copy_raw,@pointer,)
    return result.consumeIntoBytes
  end
  def equals(other)
        other = other
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_bitmap_equals,@pointer,(Bitmap._uniffi_lower other))
    return 1 == result
  end
  def fill(value)
        value = value ? true : false
      ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_bitmap_fill,@pointer,(value ? 1 : 0))
  end
  
  def get(x, y)
        x = ServicepointBindingUniffi::uniffi_in_range(x, "u64", 0, 2**64)
        y = ServicepointBindingUniffi::uniffi_in_range(y, "u64", 0, 2**64)
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_bitmap_get,@pointer,x,y)
    return 1 == result
  end
  def height()
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_bitmap_height,@pointer,)
    return result.to_i
  end
  def set(x, y, value)
        x = ServicepointBindingUniffi::uniffi_in_range(x, "u64", 0, 2**64)
        y = ServicepointBindingUniffi::uniffi_in_range(y, "u64", 0, 2**64)
        value = value ? true : false
      ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_bitmap_set,@pointer,x,y,(value ? 1 : 0))
  end
  
  def width()
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_bitmap_width,@pointer,)
    return result.to_i
  end
  
end
  
  class BrightnessGrid

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      ServicepointBindingUniffi.rust_call(
        :uniffi_servicepoint_binding_uniffi_fn_free_brightnessgrid,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a BrightnessGrid instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
  def initialize(width, height)
        width = ServicepointBindingUniffi::uniffi_in_range(width, "u64", 0, 2**64)
        height = ServicepointBindingUniffi::uniffi_in_range(height, "u64", 0, 2**64)
    pointer = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_brightnessgrid_new,width,height)
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  def self.clone(other)
        other = other
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_brightnessgrid_clone,(BrightnessGrid._uniffi_lower other)))
  end
  def self.load(width, height, data)
        width = ServicepointBindingUniffi::uniffi_in_range(width, "u64", 0, 2**64)
        height = ServicepointBindingUniffi::uniffi_in_range(height, "u64", 0, 2**64)
        data = ServicepointBindingUniffi::uniffi_bytes(data)
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_brightnessgrid_load,width,height,RustBuffer.allocFromBytes(data)))
  end
  

  def copy_raw()
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_brightnessgrid_copy_raw,@pointer,)
    return result.consumeIntoBytes
  end
  def equals(other)
        other = other
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_brightnessgrid_equals,@pointer,(BrightnessGrid._uniffi_lower other))
    return 1 == result
  end
  def fill(value)
        value = ServicepointBindingUniffi::uniffi_in_range(value, "u8", 0, 2**8)
      ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_brightnessgrid_fill,@pointer,value)
  end
  
  def get(x, y)
        x = ServicepointBindingUniffi::uniffi_in_range(x, "u64", 0, 2**64)
        y = ServicepointBindingUniffi::uniffi_in_range(y, "u64", 0, 2**64)
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_brightnessgrid_get,@pointer,x,y)
    return result.to_i
  end
  def height()
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_brightnessgrid_height,@pointer,)
    return result.to_i
  end
  def set(x, y, value)
        x = ServicepointBindingUniffi::uniffi_in_range(x, "u64", 0, 2**64)
        y = ServicepointBindingUniffi::uniffi_in_range(y, "u64", 0, 2**64)
        value = ServicepointBindingUniffi::uniffi_in_range(value, "u8", 0, 2**8)
      ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_brightnessgrid_set,@pointer,x,y,value)
  end
  
  def width()
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_brightnessgrid_width,@pointer,)
    return result.to_i
  end
  
end
  
  class CharGrid

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      ServicepointBindingUniffi.rust_call(
        :uniffi_servicepoint_binding_uniffi_fn_free_chargrid,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a CharGrid instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
  def initialize(width, height)
        width = ServicepointBindingUniffi::uniffi_in_range(width, "u64", 0, 2**64)
        height = ServicepointBindingUniffi::uniffi_in_range(height, "u64", 0, 2**64)
    pointer = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_chargrid_new,width,height)
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  def self.clone(other)
        other = other
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_chargrid_clone,(CharGrid._uniffi_lower other)))
  end
  def self.load(data)
        data = ServicepointBindingUniffi::uniffi_utf8(data)
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_chargrid_load,RustBuffer.allocFromString(data)))
  end
  

  def as_string()
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_chargrid_as_string,@pointer,)
    return result.consumeIntoString
  end
  def equals(other)
        other = other
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_chargrid_equals,@pointer,(CharGrid._uniffi_lower other))
    return 1 == result
  end
  def fill(value)
        value = ServicepointBindingUniffi::uniffi_utf8(value)
      ServicepointBindingUniffi.rust_call_with_error(CharGridError,:uniffi_servicepoint_binding_uniffi_fn_method_chargrid_fill,@pointer,RustBuffer.allocFromString(value))
  end
  
  def get(x, y)
        x = ServicepointBindingUniffi::uniffi_in_range(x, "u64", 0, 2**64)
        y = ServicepointBindingUniffi::uniffi_in_range(y, "u64", 0, 2**64)
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_chargrid_get,@pointer,x,y)
    return result.consumeIntoString
  end
  def get_col(x)
        x = ServicepointBindingUniffi::uniffi_in_range(x, "u64", 0, 2**64)
    result = ServicepointBindingUniffi.rust_call_with_error(CharGridError,:uniffi_servicepoint_binding_uniffi_fn_method_chargrid_get_col,@pointer,x)
    return result.consumeIntoString
  end
  def get_row(y)
        y = ServicepointBindingUniffi::uniffi_in_range(y, "u64", 0, 2**64)
    result = ServicepointBindingUniffi.rust_call_with_error(CharGridError,:uniffi_servicepoint_binding_uniffi_fn_method_chargrid_get_row,@pointer,y)
    return result.consumeIntoString
  end
  def height()
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_chargrid_height,@pointer,)
    return result.to_i
  end
  def set(x, y, value)
        x = ServicepointBindingUniffi::uniffi_in_range(x, "u64", 0, 2**64)
        y = ServicepointBindingUniffi::uniffi_in_range(y, "u64", 0, 2**64)
        value = ServicepointBindingUniffi::uniffi_utf8(value)
      ServicepointBindingUniffi.rust_call_with_error(CharGridError,:uniffi_servicepoint_binding_uniffi_fn_method_chargrid_set,@pointer,x,y,RustBuffer.allocFromString(value))
  end
  
  def set_col(x, col)
        x = ServicepointBindingUniffi::uniffi_in_range(x, "u64", 0, 2**64)
        col = ServicepointBindingUniffi::uniffi_utf8(col)
      ServicepointBindingUniffi.rust_call_with_error(CharGridError,:uniffi_servicepoint_binding_uniffi_fn_method_chargrid_set_col,@pointer,x,RustBuffer.allocFromString(col))
  end
  
  def set_row(y, row)
        y = ServicepointBindingUniffi::uniffi_in_range(y, "u64", 0, 2**64)
        row = ServicepointBindingUniffi::uniffi_utf8(row)
      ServicepointBindingUniffi.rust_call_with_error(CharGridError,:uniffi_servicepoint_binding_uniffi_fn_method_chargrid_set_row,@pointer,y,RustBuffer.allocFromString(row))
  end
  
  def to_cp437()
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_chargrid_to_cp437,@pointer,)
    return Cp437Grid._uniffi_allocate(result)
  end
  def width()
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_chargrid_width,@pointer,)
    return result.to_i
  end
  
end
  
  class Command

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      ServicepointBindingUniffi.rust_call(
        :uniffi_servicepoint_binding_uniffi_fn_free_command,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a Command instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  def self.bitmap_linear(offset, bitmap, compression)
        offset = ServicepointBindingUniffi::uniffi_in_range(offset, "u64", 0, 2**64)
        bitmap = bitmap
        compression = compression
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_command_bitmap_linear,offset,(BitVec._uniffi_lower bitmap),RustBuffer.alloc_from_TypeCompressionCode(compression)))
  end
  def self.bitmap_linear_and(offset, bitmap, compression)
        offset = ServicepointBindingUniffi::uniffi_in_range(offset, "u64", 0, 2**64)
        bitmap = bitmap
        compression = compression
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_command_bitmap_linear_and,offset,(BitVec._uniffi_lower bitmap),RustBuffer.alloc_from_TypeCompressionCode(compression)))
  end
  def self.bitmap_linear_or(offset, bitmap, compression)
        offset = ServicepointBindingUniffi::uniffi_in_range(offset, "u64", 0, 2**64)
        bitmap = bitmap
        compression = compression
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_command_bitmap_linear_or,offset,(BitVec._uniffi_lower bitmap),RustBuffer.alloc_from_TypeCompressionCode(compression)))
  end
  def self.bitmap_linear_win(offset_x, offset_y, bitmap, compression)
        offset_x = ServicepointBindingUniffi::uniffi_in_range(offset_x, "u64", 0, 2**64)
        offset_y = ServicepointBindingUniffi::uniffi_in_range(offset_y, "u64", 0, 2**64)
        bitmap = bitmap
        compression = compression
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_command_bitmap_linear_win,offset_x,offset_y,(Bitmap._uniffi_lower bitmap),RustBuffer.alloc_from_TypeCompressionCode(compression)))
  end
  def self.bitmap_linear_xor(offset, bitmap, compression)
        offset = ServicepointBindingUniffi::uniffi_in_range(offset, "u64", 0, 2**64)
        bitmap = bitmap
        compression = compression
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_command_bitmap_linear_xor,offset,(BitVec._uniffi_lower bitmap),RustBuffer.alloc_from_TypeCompressionCode(compression)))
  end
  def self.brightness(brightness)
        brightness = ServicepointBindingUniffi::uniffi_in_range(brightness, "u8", 0, 2**8)
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call_with_error(ServicePointError,:uniffi_servicepoint_binding_uniffi_fn_constructor_command_brightness,brightness))
  end
  def self.char_brightness(offset_x, offset_y, grid)
        offset_x = ServicepointBindingUniffi::uniffi_in_range(offset_x, "u64", 0, 2**64)
        offset_y = ServicepointBindingUniffi::uniffi_in_range(offset_y, "u64", 0, 2**64)
        grid = grid
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_command_char_brightness,offset_x,offset_y,(BrightnessGrid._uniffi_lower grid)))
  end
  def self.clear()
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_command_clear,))
  end
  def self.clone(other)
        other = other
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_command_clone,(Command._uniffi_lower other)))
  end
  def self.cp437_data(offset_x, offset_y, grid)
        offset_x = ServicepointBindingUniffi::uniffi_in_range(offset_x, "u64", 0, 2**64)
        offset_y = ServicepointBindingUniffi::uniffi_in_range(offset_y, "u64", 0, 2**64)
        grid = grid
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_command_cp437_data,offset_x,offset_y,(Cp437Grid._uniffi_lower grid)))
  end
  def self.fade_out()
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_command_fade_out,))
  end
  def self.hard_reset()
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_command_hard_reset,))
  end
  def self.utf8_data(offset_x, offset_y, grid)
        offset_x = ServicepointBindingUniffi::uniffi_in_range(offset_x, "u64", 0, 2**64)
        offset_y = ServicepointBindingUniffi::uniffi_in_range(offset_y, "u64", 0, 2**64)
        grid = grid
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_command_utf8_data,offset_x,offset_y,(CharGrid._uniffi_lower grid)))
  end
  

  def equals(other)
        other = other
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_command_equals,@pointer,(Command._uniffi_lower other))
    return 1 == result
  end
  
end
  
  class Connection

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      ServicepointBindingUniffi.rust_call(
        :uniffi_servicepoint_binding_uniffi_fn_free_connection,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a Connection instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
  def initialize(host)
        host = ServicepointBindingUniffi::uniffi_utf8(host)
    pointer = ServicepointBindingUniffi.rust_call_with_error(ServicePointError,:uniffi_servicepoint_binding_uniffi_fn_constructor_connection_new,RustBuffer.allocFromString(host))
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  def self.new_fake()
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_connection_new_fake,))
  end
  

  def send(command)
        command = command
      ServicepointBindingUniffi.rust_call_with_error(ServicePointError,:uniffi_servicepoint_binding_uniffi_fn_method_connection_send,@pointer,(Command._uniffi_lower command))
  end
  
  
end
  
  class Cp437Grid

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      ServicepointBindingUniffi.rust_call(
        :uniffi_servicepoint_binding_uniffi_fn_free_cp437grid,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a Cp437Grid instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
  def initialize(width, height)
        width = ServicepointBindingUniffi::uniffi_in_range(width, "u64", 0, 2**64)
        height = ServicepointBindingUniffi::uniffi_in_range(height, "u64", 0, 2**64)
    pointer = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_cp437grid_new,width,height)
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  def self.clone(other)
        other = other
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_cp437grid_clone,(Cp437Grid._uniffi_lower other)))
  end
  def self.load(width, height, data)
        width = ServicepointBindingUniffi::uniffi_in_range(width, "u64", 0, 2**64)
        height = ServicepointBindingUniffi::uniffi_in_range(height, "u64", 0, 2**64)
        data = ServicepointBindingUniffi::uniffi_bytes(data)
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_constructor_cp437grid_load,width,height,RustBuffer.allocFromBytes(data)))
  end
  

  def copy_raw()
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_cp437grid_copy_raw,@pointer,)
    return result.consumeIntoBytes
  end
  def equals(other)
        other = other
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_cp437grid_equals,@pointer,(Cp437Grid._uniffi_lower other))
    return 1 == result
  end
  def fill(value)
        value = ServicepointBindingUniffi::uniffi_in_range(value, "u8", 0, 2**8)
      ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_cp437grid_fill,@pointer,value)
  end
  
  def get(x, y)
        x = ServicepointBindingUniffi::uniffi_in_range(x, "u64", 0, 2**64)
        y = ServicepointBindingUniffi::uniffi_in_range(y, "u64", 0, 2**64)
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_cp437grid_get,@pointer,x,y)
    return result.to_i
  end
  def height()
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_cp437grid_height,@pointer,)
    return result.to_i
  end
  def set(x, y, value)
        x = ServicepointBindingUniffi::uniffi_in_range(x, "u64", 0, 2**64)
        y = ServicepointBindingUniffi::uniffi_in_range(y, "u64", 0, 2**64)
        value = ServicepointBindingUniffi::uniffi_in_range(value, "u8", 0, 2**8)
      ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_cp437grid_set,@pointer,x,y,value)
  end
  
  def to_utf8()
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_cp437grid_to_utf8,@pointer,)
    return CharGrid._uniffi_allocate(result)
  end
  def width()
    result = ServicepointBindingUniffi.rust_call(:uniffi_servicepoint_binding_uniffi_fn_method_cp437grid_width,@pointer,)
    return result.to_i
  end
  
end
  
end

