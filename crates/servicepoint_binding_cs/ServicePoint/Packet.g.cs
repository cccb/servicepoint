// <auto-generated>
// This code is generated by csbindgen.
// DON'T CHANGE THIS DIRECTLY.
// </auto-generated>
#pragma warning disable CS8500
#pragma warning disable CS8981
using System;
using System.Runtime.InteropServices;


namespace ServicePoint
{

    public unsafe sealed partial class Packet: IDisposable
    {
#nullable enable
        /// <summary>
        ///  Turns a [SPCommand] into a [SPPacket].
        ///  The [SPCommand] gets consumed.
        ///
        ///  Will never return NULL.
        ///
        ///  # Panics
        ///
        ///  - when `command` is NULL
        ///
        ///  # Safety
        ///
        ///  The caller has to make sure that:
        ///
        ///  - [SPCommand] points to a valid instance of [SPCommand]
        ///  - [SPCommand] is not used concurrently or after this call
        ///  - the returned [SPPacket] instance is freed in some way, either by using a consuming function or
        ///    by explicitly calling `sp_packet_free`.
        ///
        ///  servicepoint_csbindgen_consumes: command
        /// </summary>
        [System.Runtime.CompilerServices.MethodImplAttribute(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Packet FromCommand(Command command)
        {
            return new Packet(Packet.sp_packet_from_command(command.__Into()));
        }

        /// <summary>
        ///  Creates a raw [SPPacket] from parts.
        ///
        ///  # Arguments
        ///
        ///  - `command_code` specifies which command this packet contains
        ///  - `a`, `b`, `c` and `d` are command-specific header values
        ///  - `payload` is the optional data that is part of the command
        ///  - `payload_len` is the size of the payload
        ///
        ///  returns: new instance. Will never return null.
        ///
        ///  # Panics
        ///
        ///  - when `payload` is null, but `payload_len` is not zero
        ///  - when `payload_len` is zero, but `payload` is nonnull
        ///
        ///  # Safety
        ///
        ///  The caller has to make sure that:
        ///
        ///  - `payload` points to a valid memory region of at least `payload_len` bytes
        ///  - `payload` is not written to concurrently
        ///  - the returned [SPPacket] instance is freed in some way, either by using a consuming function or
        ///    by explicitly calling `sp_packet_free`.
        /// </summary>
        [System.Runtime.CompilerServices.MethodImplAttribute(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Packet FromParts(ushort command_code, ushort a, ushort b, ushort c, ushort d, byte* payload, nuint payload_len)
        {
            return new Packet(Packet.sp_packet_from_parts(command_code, a, b, c, d, payload, payload_len));
        }

        /// <summary>
        ///  Tries to load a [SPPacket] from the passed array with the specified length.
        ///
        ///  returns: NULL in case of an error, pointer to the allocated packet otherwise
        ///
        ///  # Panics
        ///
        ///  - when `data` is NULL
        ///
        ///  # Safety
        ///
        ///  The caller has to make sure that:
        ///
        ///  - `data` points to a valid memory region of at least `length` bytes
        ///  - `data` is not written to concurrently
        ///  - the returned [SPPacket] instance is freed in some way, either by using a consuming function or
        ///    by explicitly calling `sp_packet_free`.
        /// </summary>
        [System.Runtime.CompilerServices.MethodImplAttribute(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Packet? TryLoad(byte* data, nuint length)
        {
            var native = Packet.sp_packet_try_load(data, length);
            return native == null ? null : new Packet(native);
        }

        /// <summary>
        ///  Clones a [SPPacket].
        ///
        ///  Will never return NULL.
        ///
        ///  # Panics
        ///
        ///  - when `packet` is NULL
        ///
        ///  # Safety
        ///
        ///  The caller has to make sure that:
        ///
        ///  - `packet` points to a valid [SPPacket]
        ///  - `packet` is not written to concurrently
        ///  - the returned instance is freed in some way, either by using a consuming function or
        ///    by explicitly calling `sp_packet_free`.
        /// </summary>
        [System.Runtime.CompilerServices.MethodImplAttribute(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public Packet Clone()
        {
            return new Packet(Packet.sp_packet_clone(this.__Instance));
        }


#region internal machinery
        private SPPacket* _instance;
        internal SPPacket* __Instance
        {
            get
            {
                if (_instance == null)
                    throw new NullReferenceException("instance is null");
                return _instance;
            }
        }

        private Packet(SPPacket* instance)
        {
            ArgumentNullException.ThrowIfNull(instance);
            _instance = instance;
        }

        internal SPPacket* __Into()
        {
            var instance = __Instance;
            _instance = null;
            return instance;
        }

        private void __Free()
        {
            if (_instance != null)
                Packet.sp_packet_free(__Into());
        }

        public void Dispose()
        {
            __Free();
            GC.SuppressFinalize(this);
        }

        ~Packet() => __Free();
            
#endregion

#nullable restore
#region native methods
        const string __DllName = "servicepoint_binding_c";
        [DllImport(__DllName, EntryPoint = "sp_packet_from_command", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        private static extern SPPacket* sp_packet_from_command(SPCommand* command);

        [DllImport(__DllName, EntryPoint = "sp_packet_from_parts", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        private static extern SPPacket* sp_packet_from_parts(ushort command_code, ushort a, ushort b, ushort c, ushort d, byte* payload, nuint payload_len);

        [DllImport(__DllName, EntryPoint = "sp_packet_try_load", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        private static extern SPPacket* sp_packet_try_load(byte* data, nuint length);

        [DllImport(__DllName, EntryPoint = "sp_packet_clone", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        private static extern SPPacket* sp_packet_clone(SPPacket* packet);

        [DllImport(__DllName, EntryPoint = "sp_packet_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        private static extern void sp_packet_free(SPPacket* packet);


#endregion
    }

    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct SPPacket
    {
    }



}
