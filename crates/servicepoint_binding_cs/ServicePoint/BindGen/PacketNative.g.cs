// <auto-generated>
// This code is generated by csbindgen.
// DON'T CHANGE THIS DIRECTLY.
// </auto-generated>
#pragma warning disable CS8500
#pragma warning disable CS8981
using System;
using System.Runtime.InteropServices;


namespace ServicePoint.BindGen
{
    public static unsafe partial class PacketNative
    {
        const string __DllName = "servicepoint_binding_c";



        /// <summary>
        ///  Turns a [SPCommand] into a [SPPacket].
        ///  The [SPCommand] gets consumed.
        ///
        ///  Will never return NULL.
        ///
        ///  # Panics
        ///
        ///  - when `command` is NULL
        ///
        ///  # Safety
        ///
        ///  The caller has to make sure that:
        ///
        ///  - [SPCommand] points to a valid instance of [SPCommand]
        ///  - [SPCommand] is not used concurrently or after this call
        ///  - the returned [SPPacket] instance is freed in some way, either by using a consuming function or
        ///    by explicitly calling `sp_packet_free`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "sp_packet_from_command", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern SPPacket* sp_packet_from_command(SPCommand* command);

        /// <summary>
        ///  Tries to load a [SPPacket] from the passed array with the specified length.
        ///
        ///  returns: NULL in case of an error, pointer to the allocated packet otherwise
        ///
        ///  # Panics
        ///
        ///  - when `data` is NULL
        ///
        ///  # Safety
        ///
        ///  The caller has to make sure that:
        ///
        ///  - `data` points to a valid memory region of at least `length` bytes
        ///  - `data` is not written to concurrently
        ///  - the returned [SPPacket] instance is freed in some way, either by using a consuming function or
        ///    by explicitly calling `sp_packet_free`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "sp_packet_try_load", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern SPPacket* sp_packet_try_load(byte* data, nuint length);

        /// <summary>
        ///  Clones a [SPPacket].
        ///
        ///  Will never return NULL.
        ///
        ///  # Panics
        ///
        ///  - when `packet` is NULL
        ///
        ///  # Safety
        ///
        ///  The caller has to make sure that:
        ///
        ///  - `packet` points to a valid [SPPacket]
        ///  - `packet` is not written to concurrently
        ///  - the returned instance is freed in some way, either by using a consuming function or
        ///    by explicitly calling `sp_packet_free`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "sp_packet_clone", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern SPPacket* sp_packet_clone(SPPacket* packet);

        /// <summary>
        ///  Deallocates a [SPPacket].
        ///
        ///  # Panics
        ///
        ///  - when `sp_packet_free` is NULL
        ///
        ///  # Safety
        ///
        ///  The caller has to make sure that:
        ///
        ///  - `packet` points to a valid [SPPacket]
        ///  - `packet` is not used concurrently or after this call
        /// </summary>
        [DllImport(__DllName, EntryPoint = "sp_packet_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void sp_packet_free(SPPacket* packet);


    }

    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct SPPacket
    {
    }



}
